<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Veritas - Transcript Argument Analyzer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            color: #ffffff;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 700;
            background: linear-gradient(135deg, #FF6B6B, #4ECDC4);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .header p {
            color: #888;
            font-size: 1.1em;
        }

        .live-controls {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .live-controls h3 {
            color: #4ECDC4;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .live-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4444;
            animation: pulse 2s infinite;
        }

        .live-indicator.active {
            background: #44ff44;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        .session-info {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        .session-info div {
            margin-bottom: 5px;
        }

        .statement-input {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .speaker-select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 8px 12px;
            color: #fff;
            font-size: 0.9em;
        }

        .statement-text {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 10px;
            color: #fff;
            resize: vertical;
            min-height: 60px;
            font-family: inherit;
        }

        .process-btn {
            background: linear-gradient(135deg, #FF6B6B, #4ECDC4);
            border: none;
            border-radius: 6px;
            padding: 10px 15px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .process-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }

        .process-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .recent-statements {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 15px;
        }

        .statement-item {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 8px;
            font-size: 0.85em;
            border-left: 3px solid #4ECDC4;
        }

        .statement-speaker {
            font-weight: 600;
            color: #4ECDC4;
            margin-bottom: 3px;
        }

        .statement-nodes {
            color: #888;
            font-size: 0.8em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr 1fr;
            gap: 20px;
            min-height: 80vh;
        }

        .input-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .visualization-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel-title {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 15px;
            color: #fff;
        }

        textarea {
            width: 100%;
            min-height: 200px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            padding: 15px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 14px;
            line-height: 1.5;
            resize: vertical;
        }

        textarea::placeholder {
            color: #666;
        }

        textarea:focus {
            outline: none;
            border-color: #4ECDC4;
        }

        .controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }

        .btn {
            background: linear-gradient(135deg, #4ECDC4, #44A08D);
            border: none;
            border-radius: 8px;
            color: white;
            padding: 12px 24px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
        }

        .btn:disabled {
            background: #333;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        .btn-secondary:hover {
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        #graph-container {
            width: 100%;
            height: 600px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }

        .status.loading {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border: 1px solid #ffc107;
        }

        .status.success {
            background: rgba(40, 167, 69, 0.2);
            color: #28a745;
            border: 1px solid #28a745;
        }

        .status.error {
            background: rgba(220, 53, 69, 0.2);
            color: #dc3545;
            border: 1px solid #dc3545;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .stat-item {
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.8em;
            color: #888;
        }

        .sample-links {
            margin-top: 15px;
        }

        .sample-link {
            color: #4ECDC4;
            cursor: pointer;
            text-decoration: underline;
            margin-right: 15px;
            font-size: 14px;
        }

        .sample-link:hover {
            color: #44A08D;
        }

        .node {
            stroke-width: 2px;
            cursor: pointer;
        }

        .node.claim {
            fill: #FF6B6B;
            stroke: #E55656;
        }

        .node.argument {
            fill: #4ECDC4;
            stroke: #44A08D;
        }

        .node.evidence {
            fill: #667eea;
            stroke: #564ba2;
        }

        .link {
            stroke-opacity: 0.8;
            stroke-width: 2px;
        }

        .link.supports {
            stroke: #28a745;
        }

        .link.attacks {
            stroke: #dc3545;
            stroke-dasharray: 5, 5;
        }

        .link.questions {
            stroke: #ffa500;
            stroke-dasharray: 3, 3;
        }

        .node-label {
            font-size: 12px;
            fill: #fff;
            text-anchor: middle;
            pointer-events: none;
            font-weight: 500;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 200px;
            pointer-events: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .legend-text {
            font-size: 12px;
            color: #ccc;
        }

        /* Validity Assessment Styles */
        .recommendation-item {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 5px;
            font-size: 13px;
            border-left: 3px solid;
        }

        .recommendation-high {
            background: rgba(220, 53, 69, 0.1);
            border-left-color: #dc3545;
            color: #ff7a7a;
        }

        .recommendation-medium {
            background: rgba(255, 193, 7, 0.1);
            border-left-color: #ffc107;
            color: #ffd93d;
        }

        .recommendation-low {
            background: rgba(40, 167, 69, 0.1);
            border-left-color: #28a745;
            color: #51cf66;
        }

        .chain-item {
            margin-bottom: 8px;
            padding: 6px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 4px;
            font-size: 12px;
        }

        .chain-strength {
            display: inline-block;
            width: 50px;
            height: 4px;
            border-radius: 2px;
            margin-left: 5px;
        }

        .chain-strong {
            background: #28a745;
        }

        .chain-medium {
            background: #ffc107;
        }

        .chain-weak {
            background: #dc3545;
        }

        /* View Toggle Buttons */
        .btn-view {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: #ccc;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-view:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .btn-view.active {
            background: linear-gradient(135deg, #4ECDC4, #44A08D);
            color: #fff;
            border-color: #4ECDC4;
        }

        /* Tree View Styles */
        .tree-container {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            padding: 20px;
            justify-content: flex-start;
            align-items: flex-start;
        }

        .claim-tree {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            min-width: 300px;
            max-width: 400px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .claim-node {
            background: #FF6B6B;
            color: white;
            padding: 12px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
            font-weight: 600;
            font-size: 14px;
            border: 3px solid;
            position: relative;
        }

        .claim-validity {
            position: absolute;
            top: -8px;
            right: -8px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
        }

        .argument-branch {
            margin-left: 20px;
            margin-bottom: 15px;
            position: relative;
            border-left: 3px solid rgba(78, 205, 196, 0.3);
            padding-left: 15px;
        }

        .argument-node {
            background: #4ECDC4;
            color: white;
            padding: 10px 12px;
            border-radius: 6px;
            margin-bottom: 10px;
            font-size: 13px;
            border: 2px solid;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .argument-node:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(78, 205, 196, 0.3);
        }

        .argument-node::after {
            content: 'â–¼';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            transition: transform 0.3s ease;
        }

        .argument-node.collapsed::after {
            transform: translateY(-50%) rotate(-90deg);
        }

        .argument-content {
            margin-bottom: 5px;
            padding-right: 25px;
        }

        .evidence-list {
            margin-left: 15px;
            margin-top: 10px;
            padding-left: 15px;
            border-left: 2px solid rgba(102, 126, 234, 0.3);
            display: none;
            /* Initially collapsed */
        }

        .evidence-list.expanded {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
            }

            to {
                opacity: 1;
                max-height: 500px;
            }
        }

        .evidence-item {
            background: #667eea;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            margin-bottom: 8px;
            font-size: 12px;
            border: 2px solid;
            position: relative;
            transform: translateX(0);
            transition: all 0.2s ease;
        }

        .evidence-item:hover {
            transform: translateX(5px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .evidence-item::before {
            content: 'â€¢';
            position: absolute;
            left: -8px;
            top: 50%;
            transform: translateY(-50%);
            color: #667eea;
            background: #0a0a0a;
            border-radius: 50%;
            width: 12px;
            height: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
        }

        .validity-high {
            border-color: #28a745;
        }

        .validity-medium {
            border-color: #ffc107;
        }

        .validity-low {
            border-color: #dc3545;
        }

        .attack-branch {
            border-left: 3px solid #dc3545;
            margin-left: 20px;
            padding-left: 10px;
            margin-top: 15px;
        }

        .attack-label {
            color: #dc3545;
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .controls {
                flex-direction: column;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>VERITAS</h1>
            <p>Transcript Argument Analyzer - Beta Testing</p>
        </div>

        <div class="main-content">
            <!-- Live Processing Controls -->
            <div class="control-panel">
                <div class="live-controls">
                    <h3>
                        <div class="live-indicator" id="live-indicator"></div>
                        Live Processing
                    </h3>

                    <div class="session-info" id="session-info">
                        <div><strong>Session:</strong> <span id="session-id">Not Started</span></div>
                        <div><strong>Nodes:</strong> <span id="node-count">0</span></div>
                        <div><strong>Statements:</strong> <span id="statement-count">0</span></div>
                        <div><strong>Speakers:</strong> <span id="speaker-list">None</span></div>
                    </div>

                    <div class="statement-input">
                        <select class="speaker-select" id="live-speaker">
                            <option value="Speaker A">Speaker A</option>
                            <option value="Speaker B">Speaker B</option>
                            <option value="Speaker C">Speaker C</option>
                        </select>

                        <textarea class="statement-text" id="live-statement"
                            placeholder="Enter statement from live audio feed..."></textarea>

                        <button class="process-btn" id="process-statement-btn" onclick="processLiveStatement()">
                            Process Statement
                        </button>
                    </div>

                    <div class="recent-statements" id="recent-statements">
                        <!-- Recent statements will appear here -->
                    </div>

                    <div style="margin-top: 15px; display: flex; gap: 8px; flex-direction: column;">
                        <button class="process-btn" onclick="exportSessionData()"
                            style="background: linear-gradient(135deg, #667eea, #764ba2); font-size: 0.85em; padding: 8px 12px;">
                            Export Session
                        </button>
                        <button class="process-btn" onclick="resetLiveSession()"
                            style="background: linear-gradient(135deg, #ff6b6b, #ff8e8e); font-size: 0.85em; padding: 8px 12px;">
                            Reset Session
                        </button>
                    </div>
                </div>
            </div>

            <div class="input-panel">
                <div class="panel-title">Batch Analysis (Legacy)</div>

                <textarea id="transcript-input" placeholder="Paste your debate transcript here...

Example format:
Speaker A: Climate change is primarily caused by human activities.
Speaker B: That's not necessarily true. Natural climate variations have always existed.
Speaker A: But the scientific consensus shows that current warming is unprecedented and correlates with industrial emissions.

Or use the sample transcripts below to test the system."></textarea>

                <div class="sample-links">
                    <span class="sample-link" onclick="loadSample('climate')">Climate Debate Sample</span>
                    <span class="sample-link" onclick="loadSample('economy')">Economic Policy Sample</span>
                    <span class="sample-link" onclick="loadSample('tech')">Tech Regulation Sample</span>
                </div>

                <div class="controls">
                    <button class="btn" onclick="analyzeTranscript()" id="analyze-btn">
                        Analyze Arguments
                    </button>
                    <button class="btn btn-secondary" onclick="clearAll()">
                        Clear
                    </button>
                </div>

                <div id="status"></div>

                <div class="stats" id="stats" style="display: none;">
                    <div class="stat-item">
                        <div class="stat-value" id="claims-count">0</div>
                        <div class="stat-label">CLAIMS</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="arguments-count">0</div>
                        <div class="stat-label">ARGUMENTS</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="evidence-count">0</div>
                        <div class="stat-label">EVIDENCE</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="validity-score">0%</div>
                        <div class="stat-label">VALIDITY</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="supported-claims">0</div>
                        <div class="stat-label">SUPPORTED</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="evidence-chains">0</div>
                        <div class="stat-label">CHAINS</div>
                    </div>
                </div>

                <!-- Validity Assessment Panel -->
                <div id="validity-assessment"
                    style="display: none; margin-top: 20px; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.1);">
                    <div class="panel-title">Validity Assessment</div>
                    <div id="validity-recommendations" style="margin-top: 10px;"></div>
                    <div id="evidence-chains-list" style="margin-top: 15px;">
                        <h4 style="margin-bottom: 10px; color: #ccc; font-size: 14px;">Evidence Chains</h4>
                        <div id="chains-container"></div>
                    </div>
                </div>

                <!-- Real-time Input Section -->
                <div id="realtime-section"
                    style="display: none; margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.2);">
                    <div class="panel-title">Add New Statement</div>

                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <select id="speaker-select"
                            style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 5px; color: #fff; padding: 8px;">
                            <option value="Speaker A">Speaker A</option>
                            <option value="Speaker B">Speaker B</option>
                        </select>
                    </div>

                    <textarea id="new-statement" placeholder="Enter a new speaker statement..."
                        style="width: 100%; min-height: 80px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: #fff; padding: 15px; font-family: inherit; font-size: 14px; resize: vertical;"></textarea>

                    <button class="btn" onclick="addNewStatement()" id="add-statement-btn" style="margin-top: 10px;">
                        Add to Debate
                    </button>
                </div>
            </div>

            <div class="visualization-panel">
                <div class="panel-title">
                    Argument Visualization
                    <div style="float: right; display: flex; gap: 10px;">
                        <button class="btn-view active" id="tree-view-btn" onclick="switchToTreeView()">Tree
                            View</button>
                        <button class="btn-view" id="graph-view-btn" onclick="switchToGraphView()">Graph View</button>
                    </div>
                </div>
                <div style="display: flex; gap: 20px; height: 600px;">
                    <!-- Visual Tree View -->
                    <div id="tree-container"
                        style="flex: 1; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; background: rgba(0, 0, 0, 0.3); overflow: auto;">
                    </div>

                    <!-- Textual Tree Representation -->
                    <div id="textual-tree-container"
                        style="flex: 1; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; background: rgba(0, 0, 0, 0.3); overflow: auto;">
                        <div
                            style="padding: 15px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); background: rgba(255, 255, 255, 0.05);">
                            <h4
                                style="margin: 0; color: #fff; font-size: 14px; display: flex; justify-content: space-between; align-items: center;">
                                Textual Analysis
                                <button class="btn-copy" onclick="copyTextualAnalysis()"
                                    style="background: rgba(78, 205, 196, 0.8); border: none; border-radius: 4px; color: white; padding: 4px 8px; font-size: 11px; cursor: pointer;">
                                    Copy
                                </button>
                            </h4>
                        </div>
                        <pre id="textual-tree-content"
                            style="margin: 0; padding: 15px; color: #ccc; font-family: 'Monaco', 'Menlo', monospace; font-size: 12px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word;">
                            No analysis yet. Click "Analyze Arguments" to see the textual breakdown.
                        </pre>
                    </div>
                </div>
                <div id="graph-container" style="display: none;">
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FF6B6B;"></div>
                            <div class="legend-text">Claims</div>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4ECDC4;"></div>
                            <div class="legend-text">Arguments</div>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #667eea;"></div>
                            <div class="legend-text">Evidence</div>
                        </div>
                        <div class="legend-item">
                            <div style="width: 15px; height: 2px; background: #28a745; margin-right: 8px;"></div>
                            <div class="legend-text">Supports</div>
                        </div>
                        <div class="legend-item">
                            <div
                                style="width: 15px; height: 2px; background: #dc3545; margin-right: 8px; background-image: repeating-linear-gradient(to right, #dc3545 0px, #dc3545 5px, transparent 5px, transparent 10px);">
                            </div>
                            <div class="legend-text">Attacks</div>
                        </div>
                        <div class="legend-item">
                            <div style="width: 15px; height: 2px; background: #ffa500; margin-right: 8px;"></div>
                            <div class="legend-text">Questions</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Sample transcripts for testing
        const samples = {
            climate: `Speaker A: Climate change is primarily caused by human activities and requires immediate global action.

Speaker B: That's an oversimplification. Climate has always varied naturally throughout Earth's history.

Speaker A: The evidence clearly supports human causation. NASA data shows CO2 levels have increased 40% since 1950, rising from 315 ppm to over 410 ppm today. This directly correlates with global temperature increases of 1.1Â°C since pre-industrial times.

Speaker B: Correlation doesn't prove causation. Natural factors like solar activity cycles and ocean currents could explain these changes. The Medieval Warm Period occurred without industrial emissions.

Speaker A: Multiple independent research institutions confirm human influence. The IPCC's 2023 synthesis report analyzed over 14,000 peer-reviewed studies. 97% of actively publishing climate scientists agree that recent warming is primarily human-caused.

Speaker B: Scientific consensus can be wrong. Many respected climatologists question the reliability of temperature reconstructions and the accuracy of climate models, which have consistently overestimated warming rates.

Speaker A: Ice core data from Antarctica provides 800,000 years of atmospheric history. Current CO2 levels are the highest in human history, and isotopic analysis proves the excess carbon comes from fossil fuel combustion.`,

            economy: `Speaker A: Minimum wage increases are essential policy tools that help workers afford basic necessities and reduce inequality.

Speaker B: Higher minimum wages actually harm the workers they're meant to help by reducing employment opportunities.

Speaker A: This is supported by comprehensive research. A 2020 study by Reich et al. analyzed 138 minimum wage increases across the US and found employment effects were statistically insignificant. Seattle's gradual increase to $15/hour resulted in a 3% increase in worker earnings with no measurable job losses.

Speaker B: Those studies use flawed methodologies that ignore automation effects. The Congressional Budget Office projects that a $15 federal minimum wage would eliminate 1.4 million jobs by 2025. McDonald's has already installed self-service kiosks in response to wage pressures.

Speaker A: Economic multiplier effects create net job gains. When workers earn more, they spend more locally. The Economic Policy Institute calculated that a $15 minimum wage would generate $144 billion in additional wages, supporting 250,000 net new jobs through increased consumer demand.

Speaker B: This ignores the crushing burden on small businesses. National Federation of Independent Business data shows that 67% of small employers would reduce hiring if forced to pay $15/hour. Many operate on 3-5% profit margins and simply cannot absorb these costs.`,

            tech: `Speaker A: Social media platforms should be regulated like public utilities because they control information flow and public discourse.

Speaker B: Regulation would stifle innovation and violate free speech principles. Private companies have the right to moderate their own platforms.

Speaker A: But these platforms have monopolistic power over digital communication. Their content policies can silence legitimate viewpoints and manipulate elections.

Speaker B: Market competition will solve content moderation issues. Users can choose alternative platforms if they disagree with policies.

Speaker A: Network effects make it nearly impossible for new platforms to compete. Users are locked into existing platforms where their connections already exist.

Speaker B: Heavy-handed government regulation would be worse than current problems. Bureaucrats shouldn't decide what speech is acceptable online.`
        };

        let currentGraph = { nodes: [], links: [] };
        let simulation;

        function loadSample(type) {
            document.getElementById('transcript-input').value = samples[type];
        }

        function clearAll() {
            document.getElementById('transcript-input').value = '';
            document.getElementById('status').innerHTML = '';
            document.getElementById('stats').style.display = 'none';
            clearGraph();
        }

        function showStatus(message, type = 'loading') {
            const statusEl = document.getElementById('status');
            statusEl.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function updateStats(data) {
            const claims = data.nodes ? data.nodes.filter(n => n.type === 'claim').length : 0;
            const arguments = data.nodes ? data.nodes.filter(n => n.type === 'argument').length : 0;
            const evidence = data.nodes ? data.nodes.filter(n => n.type === 'evidence').length : 0;

            // Validity metrics
            const validityScore = data.validity ? Math.round(data.validity.metrics.overallValidityScore * 100) : 0;
            const supportedClaims = data.validity ? data.validity.metrics.supportedClaims : 0;
            const evidenceChains = data.validity ? data.validity.evidenceChains.length : 0;

            document.getElementById('claims-count').textContent = claims;
            document.getElementById('arguments-count').textContent = arguments;
            document.getElementById('evidence-count').textContent = evidence;
            document.getElementById('validity-score').textContent = validityScore + '%';
            document.getElementById('supported-claims').textContent = supportedClaims;
            document.getElementById('evidence-chains').textContent = evidenceChains;
            document.getElementById('stats').style.display = 'grid';

            // Show validity assessment if available
            if (data.validity) {
                displayValidityAssessment(data.validity);
            }
        }

        function displayValidityAssessment(validity) {
            const panel = document.getElementById('validity-assessment');
            const recommendationsDiv = document.getElementById('validity-recommendations');
            const chainsDiv = document.getElementById('chains-container');

            panel.style.display = 'block';

            // Display recommendations
            recommendationsDiv.innerHTML = '';
            if (validity.recommendations && validity.recommendations.length > 0) {
                validity.recommendations.forEach(rec => {
                    const recDiv = document.createElement('div');
                    recDiv.className = `recommendation-item recommendation-${rec.priority}`;
                    recDiv.innerHTML = `
                        <strong>${rec.message}</strong><br/>
                        <small>${rec.action}</small>
                    `;
                    recommendationsDiv.appendChild(recDiv);
                });
            } else {
                recommendationsDiv.innerHTML = '<div class="recommendation-item recommendation-low">No issues detected - arguments appear well-supported!</div>';
            }

            // Display evidence chains
            chainsDiv.innerHTML = '';
            if (validity.evidenceChains && validity.evidenceChains.length > 0) {
                validity.evidenceChains.forEach((chain, index) => {
                    const chainDiv = document.createElement('div');
                    chainDiv.className = 'chain-item';

                    const strengthClass = chain.chainStrength > 0.7 ? 'chain-strong' :
                        chain.chainStrength > 0.4 ? 'chain-medium' : 'chain-weak';

                    const weakLinksText = chain.weakLinks && chain.weakLinks.length > 0 ?
                        `<br/><small style="color: #ff7a7a;">Issues: ${chain.weakLinks.join(', ')}</small>` : '';

                    chainDiv.innerHTML = `
                        Chain ${index + 1}: ${chain.arguments.length} arguments, ${chain.evidence.length} evidence
                        <span class="chain-strength ${strengthClass}"></span>
                        ${Math.round(chain.chainStrength * 100)}%
                        ${weakLinksText}
                    `;
                    chainsDiv.appendChild(chainDiv);
                });
            } else {
                chainsDiv.innerHTML = '<div class="chain-item">No evidence chains found</div>';
            }
        }

        async function analyzeTranscript() {
            const transcript = document.getElementById('transcript-input').value.trim();

            if (!transcript) {
                showStatus('Please enter a transcript first.', 'error');
                return;
            }

            const analyzeBtn = document.getElementById('analyze-btn');
            analyzeBtn.disabled = true;
            analyzeBtn.textContent = 'Analyzing...';

            try {
                showStatus('ðŸ¤– Connecting to AI for analysis... (this may take 10-15 seconds)', 'loading');

                // Call our backend API
                const response = await fetch('http://localhost:3001/api/analyze-transcript', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ transcript })
                });

                if (!response.ok) {
                    throw new Error(`Backend error: ${response.status}`);
                }

                const result = await response.json();

                if (!result.success) {
                    throw new Error(result.error);
                }

                showStatus(`ðŸŽ‰ AI analysis complete! Found ${result.data.nodes.length} statements. Building tree structure...`, 'success');

                updateStats(result.data);
                renderGraph(result.data);
                showRealtimeSection();

            } catch (error) {
                console.error('Analysis error:', error);
                showStatus(`Error: ${error.message}. Please ensure the backend is running and configured correctly.`, 'error');
            } finally {
                analyzeBtn.disabled = false;
                analyzeBtn.textContent = 'Analyze Arguments';
            }
        }
        function renderGraph(data) {
            clearGraph();

            const container = document.getElementById('graph-container');
            const width = container.offsetWidth;
            const height = container.offsetHeight;

            const svg = d3.select('#graph-container')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            // Create tooltip
            const tooltip = d3.select('body')
                .append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);

            // Set up force simulation
            simulation = d3.forceSimulation(data.nodes)
                .force('link', d3.forceLink(data.links).id(d => d.id).distance(100))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(30));

            // Add links
            const link = svg.append('g')
                .selectAll('line')
                .data(data.links)
                .enter()
                .append('line')
                .attr('class', d => `link ${d.type}`)
                .attr('stroke-width', d => Math.sqrt(d.confidence * 3));

            // Add nodes with size based on type and validity
            const node = svg.append('g')
                .selectAll('circle')
                .data(data.nodes)
                .enter()
                .append('circle')
                .attr('class', d => `node ${d.type}`)
                .attr('r', d => {
                    // Size nodes based on type: Claims largest, Arguments medium, Evidence smallest
                    if (d.type === 'claim') return 30;
                    if (d.type === 'argument') return 22;
                    return 18; // evidence
                })
                .attr('opacity', d => {
                    // Opacity based on validity score if available, otherwise confidence
                    const validityScore = d.validityScore || d.confidence || 0.8;
                    return Math.max(0.4, validityScore); // Minimum opacity for visibility
                })
                .attr('stroke-width', d => {
                    // Thicker border for higher validity
                    const validityScore = d.validityScore || d.confidence || 0.8;
                    return 2 + (validityScore * 3);
                })
                .on('mouseover', function (event, d) {
                    tooltip.transition()
                        .duration(200)
                        .style('opacity', .9);

                    const validityScore = d.validityScore || d.confidence || 0.8;
                    const validityText = d.validityReason || 'Assessment pending';

                    tooltip.html(`<strong>${d.speaker}</strong><br/>
                        ${d.fullText}<br/>
                        <em>Type: ${d.type}</em><br/>
                        Confidence: ${Math.round(d.confidence * 100)}%<br/>
                        Validity: ${Math.round(validityScore * 100)}%<br/>
                        <small>${validityText}</small>`)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 28) + 'px');
                })
                .on('mouseout', function () {
                    tooltip.transition()
                        .duration(500)
                        .style('opacity', 0);
                })
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // Add node labels
            const label = svg.append('g')
                .selectAll('text')
                .data(data.nodes)
                .enter()
                .append('text')
                .attr('class', 'node-label')
                .attr('dy', 5)
                .text(d => `${d.speaker.split(' ')[1]}`);

            // Update positions on simulation tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });

            currentGraph = data;
        }

        function clearGraph() {
            d3.select('#graph-container svg').remove();
            d3.selectAll('.tooltip').remove();
            if (simulation) {
                simulation.stop();
            }
        }

        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Real-time statement addition functionality
        async function addNewStatement() {
            const speakerSelect = document.getElementById('speaker-select');
            const statementInput = document.getElementById('new-statement');
            const addBtn = document.getElementById('add-statement-btn');

            const speaker = speakerSelect.value;
            const statement = statementInput.value.trim();

            if (!statement) {
                showStatus('Please enter a statement first.', 'error');
                return;
            }

            // Disable button and show processing
            addBtn.disabled = true;
            addBtn.textContent = 'Analyzing...';

            try {
                // Format as transcript input for analysis
                const newTranscript = `${speaker}: ${statement}`;

                showStatus('Analyzing new statement...', 'loading');

                // Call backend API for analysis
                const response = await fetch('http://localhost:3001/api/analyze-transcript', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ transcript: newTranscript })
                });

                if (!response.ok) {
                    throw new Error(`Backend error: ${response.status}`);
                }

                const result = await response.json();

                if (!result.success) {
                    throw new Error(result.error);
                }

                // Add new nodes to existing graph
                addNodesToGraph(result.data);

                // Clear the input
                statementInput.value = '';

                showStatus(`New statement analyzed using ${result.data.method === 'grok' ? 'AI' : 'mock'} method!`, 'success');

            } catch (error) {
                console.error('Error analyzing new statement:', error);
                showStatus(`Error: ${error.message}`, 'error');
            } finally {
                addBtn.disabled = false;
                addBtn.textContent = 'Add to Debate';
            }
        }

        function addNodesToGraph(newData) {
            if (!currentGraph.nodes) {
                // No existing graph, render fresh
                currentGraph = newData;
                renderGraph(currentGraph);
                updateStats(currentGraph);
                return;
            }

            // Merge new data with existing graph
            const existingNodeIds = new Set(currentGraph.nodes.map(n => n.id));

            // Add new nodes (avoid duplicates)
            newData.nodes.forEach(node => {
                if (!existingNodeIds.has(node.id)) {
                    // Assign new unique ID to avoid conflicts
                    node.id = `${node.id}_${Date.now()}`;
                    currentGraph.nodes.push(node);
                }
            });

            // Add new links
            newData.links.forEach(link => {
                // Update source/target IDs if they were changed
                const updatedLink = { ...link };
                if (newData.nodes.some(n => n.id.includes('_'))) {
                    // Find matching nodes and update IDs
                    const sourceNode = currentGraph.nodes.find(n => n.fullText === newData.nodes.find(nn => nn.id === link.source)?.fullText);
                    const targetNode = currentGraph.nodes.find(n => n.fullText === newData.nodes.find(nn => nn.id === link.target)?.fullText);

                    if (sourceNode) updatedLink.source = sourceNode.id;
                    if (targetNode) updatedLink.target = targetNode.id;
                }
                currentGraph.links.push(updatedLink);
            });

            // Re-render the graph with new data
            renderGraph(currentGraph);
            updateStats(currentGraph);
        }

        // Modify the main analysis function to show real-time section
        function showRealtimeSection() {
            document.getElementById('realtime-section').style.display = 'block';
        }

        // View switching functions
        function switchToTreeView() {
            document.getElementById('tree-view-btn').classList.add('active');
            document.getElementById('graph-view-btn').classList.remove('active');
            document.getElementById('tree-container').style.display = 'block';
            document.getElementById('graph-container').style.display = 'none';

            if (currentGraph && currentGraph.nodes) {
                renderTreeView(currentGraph);
            }
        }

        function switchToGraphView() {
            document.getElementById('tree-view-btn').classList.remove('active');
            document.getElementById('graph-view-btn').classList.add('active');
            document.getElementById('tree-container').style.display = 'none';
            document.getElementById('graph-container').style.display = 'block';

            if (currentGraph && currentGraph.nodes) {
                renderGraph(currentGraph);
            }
        }

        function renderTreeView(data) {
            const container = document.getElementById('tree-container');
            container.innerHTML = '';

            // Create tree container
            const treeContainer = document.createElement('div');
            treeContainer.className = 'tree-container';

            // Group nodes by claim
            const claims = data.nodes.filter(n => n.type === 'claim');
            const arguments = data.nodes.filter(n => n.type === 'argument');
            const evidence = data.nodes.filter(n => n.type === 'evidence');

            // Create links map for quick lookup
            const linksByTarget = new Map();
            const linksBySource = new Map();

            data.links.forEach(link => {
                if (!linksByTarget.has(link.target)) linksByTarget.set(link.target, []);
                if (!linksBySource.has(link.source)) linksBySource.set(link.source, []);
                linksByTarget.get(link.target).push(link);
                linksBySource.get(link.source).push(link);
            });

            // Create a tree for each claim
            claims.forEach(claim => {
                const claimTree = createClaimTree(claim, arguments, evidence, linksByTarget, linksBySource, data.validity);
                treeContainer.appendChild(claimTree);
            });

            container.appendChild(treeContainer);

            // Generate textual representation
            generateTextualAnalysis(data, claims, arguments, evidence, linksByTarget, linksBySource);
        }

        function generateTextualAnalysis(data, claims, arguments, evidence, linksByTarget, linksBySource) {
            const textContainer = document.getElementById('textual-tree-content');
            let textualOutput = '';

            // Header with summary
            textualOutput += '='.repeat(60) + '\n';
            textualOutput += 'HIERARCHICAL ARGUMENT MAP\n';
            textualOutput += '='.repeat(60) + '\n\n';

            textualOutput += `SUMMARY:\n`;
            textualOutput += `â€¢ Main Positions: ${claims.length}\n`;
            textualOutput += `â€¢ Supporting Statements: ${arguments.length}\n`;
            textualOutput += `â€¢ Evidence/Facts: ${evidence.length}\n`;

            if (data.validity) {
                const validity = data.validity;
                textualOutput += `â€¢ Overall Validity: ${Math.round(validity.metrics.overallValidityScore * 100)}%\n`;
                textualOutput += `â€¢ Strong Evidence Chains: ${validity.metrics.strongChains}\n`;
                textualOutput += `â€¢ Weak Evidence Chains: ${validity.metrics.weakChains}\n`;
            }
            textualOutput += '\n' + '='.repeat(60) + '\n\n';

            // Group by speaker for clearer hierarchy
            const speakers = [...new Set(claims.map(c => c.speaker))];

            speakers.forEach(speaker => {
                textualOutput += `\n${speaker.toUpperCase()} POSITIONS:\n`;
                textualOutput += 'â”'.repeat(40) + '\n\n';

                const speakerClaims = claims.filter(c => c.speaker === speaker);

                speakerClaims.forEach((claim, index) => {
                    textualOutput += `ðŸ“ MAIN POSITION ${index + 1}:\n`;
                    textualOutput += `â”Œâ”€ "${claim.fullText || claim.text}"\n`;
                    textualOutput += `â”‚  Strength: ${Math.round((claim.validityScore || 0.5) * 100)}%\n`;
                    textualOutput += `â”‚\n`;

                    // Find supporting arguments
                    const supportingLinks = linksByTarget.get(claim.id) || [];
                    const supportingArguments = supportingLinks
                        .filter(link => link.type === 'supports')
                        .map(link => arguments.find(arg => arg.id === link.source))
                        .filter(Boolean);

                    if (supportingArguments.length > 0) {
                        supportingArguments.forEach((argument, argIndex) => {
                            const isLast = argIndex === supportingArguments.length - 1;
                            const argPrefix = isLast ? 'â””â”€â”€' : 'â”œâ”€â”€';
                            const childPrefix = isLast ? '   ' : 'â”‚  ';

                            textualOutput += `${argPrefix} ðŸ”— SUPPORT: "${argument.fullText || argument.text}"\n`;
                            textualOutput += `${childPrefix} Strength: ${Math.round((argument.validityScore || 0.5) * 100)}%\n`;

                            // Find evidence for this argument
                            const argLinks = linksByTarget.get(argument.id) || [];
                            const supportingEvidence = argLinks
                                .filter(link => link.type === 'supports')
                                .map(link => evidence.find(ev => ev.id === link.source))
                                .filter(Boolean);

                            if (supportingEvidence.length > 0) {
                                textualOutput += `${childPrefix} Data/Facts:\n`;
                                supportingEvidence.forEach((ev, evIndex) => {
                                    const evIsLast = evIndex === supportingEvidence.length - 1;
                                    const evPrefix = evIsLast ? 'â””â”€â”€' : 'â”œâ”€â”€';
                                    textualOutput += `${childPrefix} ${evPrefix} ðŸ“Š "${ev.fullText || ev.text}"\n`;
                                    textualOutput += `${childPrefix} ${evIsLast ? '   ' : 'â”‚  '} Reliability: ${Math.round((ev.validityScore || 0.8) * 100)}%\n`;
                                });
                            } else {
                                textualOutput += `${childPrefix} âš ï¸  No factual backing provided\n`;
                            }
                            textualOutput += `${childPrefix}\n`;
                        });
                    } else {
                        textualOutput += `â””â”€â”€ âš ï¸  No supporting arguments provided\n`;
                    }

                    // Find opposing statements from other speakers
                    const opposingStatements = data.links
                        .filter(link => link.type === 'opposes' && link.target === claim.id)
                        .map(link => data.nodes.find(node => node.id === link.source))
                        .filter(Boolean);

                    if (opposingStatements.length > 0) {
                        textualOutput += `\nâŒ OPPOSITION:\n`;
                        opposingStatements.forEach((opposition, oppIndex) => {
                            textualOutput += `â”œâ”€â”€ âš¡ "${opposition.fullText || opposition.text}"\n`;
                            textualOutput += `â”‚   From: ${opposition.speaker}\n`;
                        });
                    }

                    textualOutput += '\n' + '-'.repeat(50) + '\n';
                });
            });

            // Add validity recommendations
            if (data.validity && data.validity.recommendations) {
                textualOutput += 'RECOMMENDATIONS FOR IMPROVEMENT:\n';
                textualOutput += '='.repeat(40) + '\n';
                data.validity.recommendations.forEach((rec, index) => {
                    const priority = rec.priority.toUpperCase();
                    const icon = priority === 'HIGH' ? 'ðŸ”´' : priority === 'MEDIUM' ? 'ðŸŸ¡' : 'ðŸŸ¢';
                    textualOutput += `${index + 1}. ${icon} ${priority} PRIORITY\n`;
                    textualOutput += `   Issue: ${rec.message}\n`;
                    textualOutput += `   Action: ${rec.action}\n\n`;
                });
            }

            textContainer.textContent = textualOutput;
        }

        function copyTextualAnalysis() {
            const content = document.getElementById('textual-tree-content').textContent;
            navigator.clipboard.writeText(content).then(() => {
                const btn = document.querySelector('.btn-copy');
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                btn.style.background = 'rgba(40, 167, 69, 0.8)';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = 'rgba(78, 205, 196, 0.8)';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        }

        function createClaimTree(claim, allArguments, allEvidence, linksByTarget, linksBySource, validity) {
            const treeDiv = document.createElement('div');
            treeDiv.className = 'claim-tree';

            // Create claim node
            const claimNode = document.createElement('div');
            claimNode.className = 'claim-node';

            // Determine validity class
            const validityScore = claim.validityScore || 0.5;
            const validityClass = validityScore > 0.7 ? 'validity-high' :
                validityScore > 0.4 ? 'validity-medium' : 'validity-low';
            claimNode.classList.add(validityClass);

            claimNode.innerHTML = `
                ${claim.text || claim.fullText}
                <div class="claim-validity">${Math.round(validityScore * 100)}%</div>
            `;

            treeDiv.appendChild(claimNode);

            // Find arguments that support this claim
            const supportingLinks = linksByTarget.get(claim.id) || [];
            const supportingArguments = supportingLinks
                .filter(link => link.type === 'supports')
                .map(link => allArguments.find(arg => arg.id === link.source))
                .filter(Boolean);

            // Add supporting arguments
            supportingArguments.forEach(argument => {
                const argBranch = createArgumentBranch(argument, allEvidence, linksByTarget);
                treeDiv.appendChild(argBranch);
            });

            // Find and add attacking arguments
            const attackingArguments = supportingLinks
                .filter(link => link.type === 'attacks')
                .map(link => allArguments.find(arg => arg.id === link.source))
                .filter(Boolean);

            if (attackingArguments.length > 0) {
                const attackSection = document.createElement('div');
                attackSection.className = 'attack-branch';

                const attackLabel = document.createElement('div');
                attackLabel.className = 'attack-label';
                attackLabel.textContent = 'Challenges:';
                attackSection.appendChild(attackLabel);

                attackingArguments.forEach(argument => {
                    const argBranch = createArgumentBranch(argument, allEvidence, linksByTarget, true);
                    attackSection.appendChild(argBranch);
                });

                treeDiv.appendChild(attackSection);
            }

            return treeDiv;
        }

        function createArgumentBranch(argument, allEvidence, linksByTarget, isAttack = false) {
            const branch = document.createElement('div');
            branch.className = 'argument-branch';

            const argNode = document.createElement('div');
            argNode.className = 'argument-node collapsed'; // Start collapsed

            const validityScore = argument.validityScore || 0.5;
            const validityClass = validityScore > 0.7 ? 'validity-high' :
                validityScore > 0.4 ? 'validity-medium' : 'validity-low';
            argNode.classList.add(validityClass);

            if (isAttack) {
                argNode.style.background = '#dc3545';
                argNode.style.borderColor = '#b21f2d';
            }

            // Create content div for the argument text
            const argContent = document.createElement('div');
            argContent.className = 'argument-content';
            argContent.textContent = argument.text || argument.fullText;
            argNode.appendChild(argContent);

            // Find evidence that supports this argument
            const supportingLinks = linksByTarget.get(argument.id) || [];
            let supportingEvidence = supportingLinks
                .filter(link => link.type === 'supports')
                .map(link => allEvidence.find(ev => ev.id === link.source))
                .filter(Boolean);

            // Fallback: if no formally linked evidence, try to find evidence from same speaker
            if (supportingEvidence.length === 0) {
                // Find evidence from same speaker that hasn't been used yet
                const usedEvidenceIds = new Set();
                // Get all evidence that's already been assigned to other arguments
                document.querySelectorAll('.evidence-item').forEach(item => {
                    const evidenceText = item.textContent;
                    allEvidence.forEach(ev => {
                        if ((ev.text || ev.fullText) === evidenceText) {
                            usedEvidenceIds.add(ev.id);
                        }
                    });
                });

                supportingEvidence = allEvidence.filter(ev =>
                    ev.speaker === argument.speaker &&
                    !usedEvidenceIds.has(ev.id)
                ).slice(0, 2); // Limit to 2 pieces of evidence per argument
            }

            // Create evidence list
            const evidenceList = document.createElement('div');
            evidenceList.className = 'evidence-list';

            if (supportingEvidence.length > 0) {
                supportingEvidence.forEach(evidence => {
                    const evidenceItem = document.createElement('div');
                    evidenceItem.className = 'evidence-item';

                    const evValidityScore = evidence.validityScore || 0.8;
                    const evValidityClass = evValidityScore > 0.7 ? 'validity-high' :
                        evValidityScore > 0.4 ? 'validity-medium' : 'validity-low';
                    evidenceItem.classList.add(evValidityClass);

                    evidenceItem.textContent = evidence.text || evidence.fullText;
                    evidenceList.appendChild(evidenceItem);
                });
            } else {
                // Add a placeholder if no evidence
                const noEvidenceItem = document.createElement('div');
                noEvidenceItem.className = 'evidence-item';
                noEvidenceItem.style.background = 'rgba(220, 53, 69, 0.7)';
                noEvidenceItem.style.borderColor = '#dc3545';
                noEvidenceItem.textContent = 'No supporting evidence provided';
                evidenceList.appendChild(noEvidenceItem);
            }

            // Add click handler for expand/collapse
            argNode.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleArgumentEvidence(argNode, evidenceList);
            });

            branch.appendChild(argNode);
            branch.appendChild(evidenceList);

            return branch;
        }

        function toggleArgumentEvidence(argNode, evidenceList) {
            const isCollapsed = argNode.classList.contains('collapsed');

            if (isCollapsed) {
                // Expand
                argNode.classList.remove('collapsed');
                evidenceList.classList.add('expanded');
            } else {
                // Collapse
                argNode.classList.add('collapsed');
                evidenceList.classList.remove('expanded');
            }
        }

        // Override the main render function to use tree view by default
        function renderGraph(data) {
            // Store the current view preference
            const isTreeView = document.getElementById('tree-view-btn').classList.contains('active');

            if (isTreeView) {
                renderTreeView(data);
                return;
            }

            // Original graph rendering code
            clearGraph();

            const container = document.getElementById('graph-container');
            const width = container.offsetWidth;
            const height = container.offsetHeight;

            const svg = d3.select('#graph-container')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            // Create tooltip
            const tooltip = d3.select('body')
                .append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);

            // Set up force simulation
            simulation = d3.forceSimulation(data.nodes)
                .force('link', d3.forceLink(data.links).id(d => d.id).distance(100))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(30));

            // Add links
            const link = svg.append('g')
                .selectAll('line')
                .data(data.links)
                .enter()
                .append('line')
                .attr('class', d => `link ${d.type}`)
                .attr('stroke-width', d => Math.sqrt(d.confidence * 3));

            // Add nodes with size based on type and validity
            const node = svg.append('g')
                .selectAll('circle')
                .data(data.nodes)
                .enter()
                .append('circle')
                .attr('class', d => `node ${d.type}`)
                .attr('r', d => {
                    // Size nodes based on type: Claims largest, Arguments medium, Evidence smallest
                    if (d.type === 'claim') return 30;
                    if (d.type === 'argument') return 22;
                    return 18; // evidence
                })
                .attr('opacity', d => {
                    // Opacity based on validity score if available, otherwise confidence
                    const validityScore = d.validityScore || d.confidence || 0.8;
                    return Math.max(0.4, validityScore); // Minimum opacity for visibility
                })
                .attr('stroke-width', d => {
                    // Thicker border for higher validity
                    const validityScore = d.validityScore || d.confidence || 0.8;
                    return 2 + (validityScore * 3);
                })
                .on('mouseover', function (event, d) {
                    tooltip.transition()
                        .duration(200)
                        .style('opacity', .9);

                    const validityScore = d.validityScore || d.confidence || 0.8;
                    const validityText = d.validityReason || 'Assessment pending';

                    tooltip.html(`<strong>${d.speaker}</strong><br/>
                        ${d.fullText}<br/>
                        <em>Type: ${d.type}</em><br/>
                        Confidence: ${Math.round(d.confidence * 100)}%<br/>
                        Validity: ${Math.round(validityScore * 100)}%<br/>
                        <small>${validityText}</small>`)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 28) + 'px');
                })
                .on('mouseout', function () {
                    tooltip.transition()
                        .duration(500)
                        .style('opacity', 0);
                })
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // Add node labels
            const label = svg.append('g')
                .selectAll('text')
                .data(data.nodes)
                .enter()
                .append('text')
                .attr('class', 'node-label')
                .attr('dy', 5)
                .text(d => `${d.speaker.split(' ')[1]}`);

            // Update positions on simulation tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });

            currentGraph = data;
        }

        // =====================================================
        // LIVE PROCESSING FUNCTIONALITY
        // =====================================================

        let currentSessionId = null;
        let sessionStats = {
            nodes: 0,
            statements: 0,
            speakers: new Set()
        };
        let recentStatements = [];
        let liveGraphData = { nodes: [], links: [], evidenceChains: [] };

        // Initialize live processing interface
        function initializeLiveProcessing() {
            updateSessionUI();

            // Auto-generate session ID
            currentSessionId = 'session_' + Date.now();
            document.getElementById('session-id').textContent = currentSessionId;

            // Enable live indicator animation
            const indicator = document.getElementById('live-indicator');
            indicator.classList.add('active');

            console.log('ðŸŽ¤ Live processing initialized with session:', currentSessionId);
        }

        // Process individual statement from live feed
        async function processLiveStatement() {
            const speaker = document.getElementById('live-speaker').value;
            const statement = document.getElementById('live-statement').value.trim();

            if (!statement) {
                alert('Please enter a statement to process');
                return;
            }

            if (!currentSessionId) {
                initializeLiveProcessing();
            }

            const processBtn = document.getElementById('process-statement-btn');
            processBtn.disabled = true;
            processBtn.textContent = 'Processing...';

            try {
                console.log(`ðŸ”„ Processing statement from ${speaker}:`, statement.substring(0, 50) + '...');

                const response = await fetch('http://localhost:3001/api/process-statement', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        statement: statement,
                        speaker: speaker,
                        sessionId: currentSessionId,
                        metadata: {
                            timestamp: new Date().toISOString(),
                            source: 'manual_input'
                        }
                    })
                });

                const result = await response.json();

                if (result.success) {
                    console.log('âœ… Statement processed successfully:', result.message);

                    // Update session stats
                    sessionStats.statements = sessionStats.statements + 1;
                    sessionStats.speakers.add(speaker);

                    // Fetch the latest graph state to get actual nodes/links
                    const graphResponse = await fetch(`http://localhost:3001/api/graph-state/${currentSessionId}`);
                    const graphData = await graphResponse.json();

                    if (graphData.success) {
                        liveGraphData.nodes = graphData.nodes;
                        liveGraphData.links = graphData.links;
                        sessionStats.nodes = graphData.nodeCount;
                    }

                    // Add to recent statements
                    addToRecentStatements(speaker, statement, result.newNodes || 0);

                    // Update UI
                    updateSessionUI();

                    // Update visualization with incremental data
                    updateLiveVisualization();

                    // Clear input
                    document.getElementById('live-statement').value = '';


                } else {
                    console.error('âŒ Failed to process statement:', result.error);
                    alert('Failed to process statement: ' + result.error);
                }

            } catch (error) {
                console.error('âŒ Error processing statement:', error);
                alert('Error: ' + error.message);
            } finally {
                processBtn.disabled = false;
                processBtn.textContent = 'Process Statement';
            }
        }

        // Add statement to recent statements list
        function addToRecentStatements(speaker, statement, nodeCount) {
            const item = {
                speaker: speaker,
                statement: statement.substring(0, 100) + (statement.length > 100 ? '...' : ''),
                nodeCount: nodeCount,
                timestamp: new Date().toISOString()
            };

            recentStatements.unshift(item);
            if (recentStatements.length > 5) {
                recentStatements.pop();
            }

            // Update recent statements UI
            const container = document.getElementById('recent-statements');
            container.innerHTML = '';

            recentStatements.forEach(item => {
                const div = document.createElement('div');
                div.className = 'statement-item';
                div.innerHTML = `
                    <div class="statement-speaker">${item.speaker}</div>
                    <div>${item.statement}</div>
                    <div class="statement-nodes">${item.nodeCount} nodes extracted</div>
                `;
                container.appendChild(div);
            });
        }

        // Update session information UI
        function updateSessionUI() {
            document.getElementById('node-count').textContent = sessionStats.nodes;
            document.getElementById('statement-count').textContent = sessionStats.statements;
            document.getElementById('speaker-list').textContent =
                sessionStats.speakers.size > 0 ? Array.from(sessionStats.speakers).join(', ') : 'None';
        }

        // Update live visualization with new data
        async function updateLiveVisualization() {
            if (liveGraphData.nodes.length === 0) return;

            // Get full session state for complete visualization
            try {
                const response = await fetch(`http://localhost:3002/api/graph-state/${currentSessionId}`);
                const sessionData = await response.json();

                if (sessionData.success) {
                    // Update the visualization with complete session data
                    renderGraph({
                        nodes: sessionData.nodes,
                        links: sessionData.links,
                        evidenceChains: sessionData.evidenceChains,
                        method: 'live'
                    });
                }
            } catch (error) {
                console.error('Error updating visualization:', error);
                // Fallback to local data
                renderGraph(liveGraphData);
            }
        }

        // Export current session data
        async function exportSessionData() {
            if (!currentSessionId) {
                alert('No active session to export');
                return;
            }

            try {
                const response = await fetch(`http://localhost:3002/api/graph-state/${currentSessionId}`);
                const sessionData = await response.json();

                if (sessionData.success) {
                    const exportData = {
                        sessionId: currentSessionId,
                        exportTime: new Date().toISOString(),
                        stats: {
                            nodeCount: sessionData.nodeCount,
                            linkCount: sessionData.linkCount,
                            statementCount: sessionData.statementCount,
                            speakers: sessionData.speakers
                        },
                        data: {
                            nodes: sessionData.nodes,
                            links: sessionData.links,
                            evidenceChains: sessionData.evidenceChains
                        }
                    };

                    // Download as JSON
                    const blob = new Blob([JSON.stringify(exportData, null, 2)],
                        { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `veritas_session_${currentSessionId}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            } catch (error) {
                console.error('Error exporting session:', error);
                alert('Failed to export session data');
            }
        }

        // Reset session
        function resetLiveSession() {
            if (currentSessionId && confirm('Reset current session? This will clear all processed statements.')) {
                fetch('http://localhost:3002/api/clear-sessions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId: currentSessionId })
                });

                currentSessionId = null;
                sessionStats = { nodes: 0, statements: 0, speakers: new Set() };
                recentStatements = [];
                liveGraphData = { nodes: [], links: [], evidenceChains: [] };

                document.getElementById('session-id').textContent = 'Not Started';
                document.getElementById('recent-statements').innerHTML = '';
                document.getElementById('live-indicator').classList.remove('active');

                updateSessionUI();
                clearGraph();

                console.log('ðŸ—‘ï¸ Session reset');
            }
        }

        // Add keyboard shortcut for quick processing
        document.addEventListener('keydown', function (event) {
            if (event.ctrlKey && event.key === 'Enter') {
                event.preventDefault();
                processLiveStatement();
            }
        });

        // Load default sample on page load
        window.addEventListener('load', () => {
            loadSample('climate');
            initializeLiveProcessing();
        });
    </script>
</body>

</html>