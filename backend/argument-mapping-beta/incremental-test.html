<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Incremental Claim Processing Test</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .input-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .graph-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #network {
            border: 1px solid #ddd;
            background: #fafafa;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat {
            padding: 10px;
            background: #e3f2fd;
            border-radius: 4px;
            text-align: center;
            flex: 1;
        }

        .stat h3 {
            margin: 0;
            color: #1976d2;
        }

        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
        }

        select, button {
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            cursor: pointer;
        }

        button {
            background: #1976d2;
            color: white;
            border: 1px solid #1976d2;
        }

        button:hover {
            background: #1565c0;
        }

        .node {
            cursor: move;
        }

        .link {
            stroke: #999;
            stroke-opacity: 0.8;
        }

        .link.supports {
            stroke: #4caf50;
            stroke-width: 2px;
        }

        .link.attacks {
            stroke: #f44336;
            stroke-width: 2px;
            stroke-dasharray: 5,5;
        }

        .link.responds {
            stroke: #2196f3;
            stroke-width: 2px;
        }

        .node circle {
            fill: #fff;
            stroke: #1976d2;
            stroke-width: 2px;
        }

        .node.assertion circle {
            fill: #c8e6c9;
        }

        .node.evidence circle {
            fill: #bbdefb;
        }

        .node.reasoning circle {
            fill: #fff9c4;
        }

        .node text {
            font: 12px sans-serif;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
        }

        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            max-width: 300px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§  Incremental Claim Processing Test</h1>

        <div class="input-section">
            <h2>Add New Statement</h2>
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <select id="speakerSelect">
                    <option value="Speaker A">Speaker A</option>
                    <option value="Speaker B">Speaker B</option>
                </select>
                <button onclick="clearGraph()">Clear Graph</button>
                <button onclick="loadCurrentState()">Load Current State</button>
            </div>
            <textarea id="statementText" rows="3" placeholder="Enter a statement from a speaker..."></textarea>
            <button onclick="addStatement()" style="margin-top: 10px;">Extract Claims & Add to Graph</button>
        </div>

        <div class="stats">
            <div class="stat">
                <h3 id="claimCount">0</h3>
                <p>Total Claims</p>
            </div>
            <div class="stat">
                <h3 id="relationshipCount">0</h3>
                <p>Relationships</p>
            </div>
            <div class="stat">
                <h3 id="speakerCount">0</h3>
                <p>Speakers</p>
            </div>
        </div>

        <div class="graph-section">
            <h2>Argument Network</h2>
            <svg id="network" width="1000" height="600"></svg>
        </div>
    </div>

    <div class="tooltip" id="tooltip" style="display: none;"></div>

    <script>
        const svg = d3.select("#network");
        const tooltip = d3.select("#tooltip");
        let nodes = [];
        let links = [];
        let simulation;

        // Initialize force simulation
        function initSimulation() {
            simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(80))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(500, 300))
                .force("collision", d3.forceCollide().radius(30));
        }

        // Update visualization
        function updateVisualization() {
            // Update links
            const link = svg.selectAll(".link")
                .data(links)
                .join("line")
                .attr("class", d => `link ${d.type}`)
                .attr("stroke-width", 2);

            // Update nodes
            const node = svg.selectAll(".node")
                .data(nodes)
                .join("g")
                .attr("class", d => `node ${d.type}`)
                .call(d3.drag()
                    .on("start", dragStarted)
                    .on("drag", dragged)
                    .on("end", dragEnded));

            node.selectAll("circle").remove();
            node.selectAll("text").remove();

            node.append("circle")
                .attr("r", 20);

            node.append("text")
                .text(d => d.text.length > 15 ? d.text.substring(0, 12) + "..." : d.text)
                .style("font-size", "10px");

            // Add hover events
            node.on("mouseover", function(event, d) {
                tooltip.style("display", "block")
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 10) + "px")
                    .html(`<strong>${d.speaker}</strong><br/>
                           <em>${d.type}</em><br/>
                           ${d.fullText}<br/>
                           <small>Theme: ${d.theme}</small>`);
            })
            .on("mouseout", function() {
                tooltip.style("display", "none");
            });

            // Update simulation
            if (simulation) {
                simulation.nodes(nodes);
                simulation.force("link").links(links);
                simulation.alpha(0.3).restart();
            }

            // Update positions on tick
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("transform", d => `translate(${d.x},${d.y})`);
            });
        }

        // Update statistics
        function updateStats() {
            const speakers = new Set(nodes.map(n => n.speaker));
            document.getElementById('claimCount').textContent = nodes.length;
            document.getElementById('relationshipCount').textContent = links.length;
            document.getElementById('speakerCount').textContent = speakers.size;
        }

        // Drag functions
        function dragStarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragEnded(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // API functions
        async function addStatement() {
            const statement = document.getElementById('statementText').value.trim();
            const speaker = document.getElementById('speakerSelect').value;

            if (!statement) {
                alert('Please enter a statement');
                return;
            }

            try {
                // Extract claims
                const extractResponse = await fetch('/api/extract-claims', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({statement, speaker})
                });

                const extractData = await extractResponse.json();
                if (!extractData.success) {
                    throw new Error(extractData.error);
                }

                console.log('Extracted claims:', extractData.claims);

                // Add claims to bank
                const addResponse = await fetch('/api/add-claims', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({claims: extractData.claims})
                });

                const addData = await addResponse.json();
                if (!addData.success) {
                    throw new Error(addData.error);
                }

                console.log('Added to bank:', addData);

                // Reload graph state
                await loadCurrentState();

                // Clear input
                document.getElementById('statementText').value = '';

            } catch (error) {
                alert('Error: ' + error.message);
                console.error(error);
            }
        }

        async function loadCurrentState() {
            try {
                const response = await fetch('/api/graph-state');
                const data = await response.json();

                if (data.success) {
                    nodes = data.nodes;
                    // For this simple test, we'll show the internal relationships only
                    // In a full implementation, we'd need an endpoint that returns links
                    links = [
                        // Support relationships between same speaker claims
                        {source: "claim_3", target: "claim_2", type: "supports"},
                        {source: "claim_4", target: "claim_2", type: "supports"},
                        {source: "claim_4", target: "claim_3", type: "supports"},
                        {source: "claim_6", target: "claim_5", type: "supports"},
                        {source: "claim_10", target: "claim_7", type: "supports"}
                    ].filter(link =>
                        nodes.find(n => n.id === link.source) &&
                        nodes.find(n => n.id === link.target)
                    );

                    if (!simulation) {
                        initSimulation();
                    }

                    updateVisualization();
                    updateStats();
                }
            } catch (error) {
                console.error('Error loading graph state:', error);
            }
        }

        async function clearGraph() {
            try {
                await fetch('/api/clear-claims', {method: 'POST'});
                nodes = [];
                links = [];
                svg.selectAll("*").remove();
                updateStats();
            } catch (error) {
                console.error('Error clearing graph:', error);
            }
        }

        // Load initial state
        loadCurrentState();
    </script>
</body>
</html>